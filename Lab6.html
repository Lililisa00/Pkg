<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Matrix Studio - Letter C Rounded</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.2.1/math.js"></script>

    <style>
        :root {
            --bg-body: #0f172a;       /* –ì–ª—É–±–æ–∫–∏–π —Ç–µ–º–Ω–æ-—Å–∏–Ω–∏–π */
            --bg-card: #1e293b;       /* –¶–≤–µ—Ç –ø–∞–Ω–µ–ª–µ–π */
            --accent-primary: #38bdf8; /* –ì–æ–ª—É–±–æ–π –Ω–µ–æ–Ω */
            --accent-secondary: #818cf8; /* –§–∏–æ–ª–µ—Ç–æ–≤—ã–π */
            --text-main: #f1f5f9;     /* –°–≤–µ—Ç–ª—ã–π —Ç–µ–∫—Å—Ç */
            --text-muted: #94a3b8;    /* –ü—Ä–∏–≥–ª—É—à–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç */
            --border: #334155;        /* –ì—Ä–∞–Ω–∏—Ü—ã */
            --danger: #ef4444;        /* –ö—Ä–∞—Å–Ω—ã–π */
            --glass: rgba(30, 41, 59, 0.7);
        }

        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background-color: var(--bg-body);
            color: var(--text-main);
            margin: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
        }

        .container {
            display: flex;
            width: 100%;
            height: 100%;
        }

        /* –ì–†–ê–§–ò–ö */
        .plot-area {
            flex: 1;
            background-color: var(--bg-body);
            position: relative;
        }

        /* –ü–ê–ù–ï–õ–¨ –£–ü–†–ê–í–õ–ï–ù–ò–Ø */
        .control-panel {
            width: 400px;
            background-color: var(--bg-card);
            padding: 24px;
            overflow-y: auto;
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: -10px 0 25px rgba(0,0,0,0.3);
        }

        h3 {
            margin: 0;
            font-size: 1.5rem;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            font-weight: 800;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }

        .control-group {
            background: rgba(255,255,255,0.03);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        label {
            display: block;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            margin-bottom: 10px;
            font-weight: 700;
        }

        .input-row {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        input[type="number"] {
            flex: 1;
            padding: 10px;
            background: #0f172a;
            border: 1px solid var(--border);
            color: var(--accent-primary);
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-weight: bold;
            outline: none;
            transition: border-color 0.2s;
        }

        input[type="number"]:focus {
            border-color: var(--accent-primary);
        }

        button {
            padding: 10px 16px;
            border-radius: 6px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--accent-primary);
            color: #0f172a;
            width: 100%;
        }

        .btn-primary:hover {
            filter: brightness(1.1);
            transform: translateY(-1px);
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--accent-secondary);
            color: var(--accent-secondary);
        }

        .btn-outline:hover {
            background: var(--accent-secondary);
            color: white;
        }

        .btn-reset {
            background: rgba(239, 68, 68, 0.1);
            color: var(--danger);
            border: 1px solid var(--danger);
            width: 100%;
        }

        .btn-reset:hover {
            background: var(--danger);
            color: white;
        }

        /* –ú–ê–¢–†–ò–¶–ê */
        #matrixOutput {
            width: 100%;
            height: 160px;
            background: #0a0f1d;
            border: 1px solid var(--border);
            border-radius: 8px;
            color: #10b981; /* –ó–µ–ª–µ–Ω—ã–π "–∫–æ–¥–µ—Ä—Å–∫–∏–π" —Ü–≤–µ—Ç */
            padding: 12px;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            resize: none;
            box-sizing: border-box;
        }

        /* –ú–û–î–ê–õ–¨–ù–û–ï –û–ö–ù–û */
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(12px);
            z-index: 100;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal-content {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 20px;
            width: 95%;
            height: 90%;
            display: flex;
            flex-direction: column;
            padding: 24px;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .projections-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            flex: 1;
        }

        .proj-plot {
            background: #0f172a;
            border: 1px solid var(--border);
            border-radius: 12px;
        }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg-body); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 10px; }
    </style>
</head>
<body>

    <div class="container">
        <div id="plot3d" class="plot-area"></div>

        <div class="control-panel">
            <h3>Matrix Studio</h3>

            <div class="control-group">
                <label>–í—Ä–∞—â–µ–Ω–∏–µ –ø–æ –æ—Å—è–º</label>
                <div class="input-row">
                    <input type="number" id="rotX" value="0" placeholder="X¬∞">
                    <button onclick="applyRotation('x')" class="btn-outline">X</button>
                </div>
                <div class="input-row">
                    <input type="number" id="rotY" value="0" placeholder="Y¬∞">
                    <button onclick="applyRotation('y')" class="btn-outline">Y</button>
                </div>
                <div class="input-row">
                    <input type="number" id="rotZ" value="0" placeholder="Z¬∞">
                    <button onclick="applyRotation('z')" class="btn-outline">Z</button>
                </div>
            </div>

            <div class="control-group">
                <label>–ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ</label>
                <div class="input-row">
                    <input type="number" id="scaleVal" value="1" step="0.1">
                </div>
                <button onclick="applyScale()" class="btn-primary">–ü—Ä–∏–º–µ–Ω–∏—Ç—å –º–∞—Å—à—Ç–∞–±</button>
            </div>

            <div class="control-group">
                <label>–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ (X, Y, Z)</label>
                <div class="input-row">
                    <input type="number" id="transX" value="0">
                    <input type="number" id="transY" value="0">
                    <input type="number" id="transZ" value="0">
                </div>
                <button onclick="applyTranslation()" class="btn-primary">–ü—Ä–∏–º–µ–Ω–∏—Ç—å —Å–¥–≤–∏–≥</button>
            </div>

            <div style="display: flex; flex-direction: column; gap: 10px; margin-top: auto;">
                <button onclick="showProjections()" class="btn-outline">üìä –ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–æ–µ–∫—Ü–∏–∏</button>
                <button onclick="resetView()" class="btn-reset">‚ôªÔ∏è –°–±—Ä–æ—Å–∏—Ç—å —Å—Ü–µ–Ω—É</button>
            </div>

            <div>
                <label>–ú–∞—Ç—Ä–∏—Ü–∞ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è</label>
                <textarea id="matrixOutput" readonly></textarea>
            </div>
        </div>
    </div>

    <div id="projModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="margin:0;">–û—Ä—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–µ–∫—Ü–∏–∏</h2>
                <button onclick="closeProjections()" class="btn-outline" style="border-radius: 50px;">–ó–∞–∫—Ä—ã—Ç—å</button>
            </div>
            <div class="projections-grid">
                <div id="projXY" class="proj-plot"></div>
                <div id="projXZ" class="proj-plot"></div>
                <div id="projYZ" class="proj-plot"></div>
            </div>
        </div>
    </div>

    <script>
        // –ì–ï–ù–ï–†–ê–¶–ò–Ø –ó–ê–ö–†–£–ì–õ–ï–ù–ù–û–ô –ë–£–ö–í–´ C
        const initialVertices = [];
        const edges = [];

        function generateGeometry() {
            const corners = [
                {cx: 3.5, cy: 0.5, r: 0.5, s: 0, e: -90},   // –£–≥–æ–ª (4,0)
                {cx: 0.5, cy: 0.5, r: 0.5, s: 270, e: 180}, // –£–≥–æ–ª (0,0)
                {cx: 0.5, cy: 4.5, r: 0.5, s: 180, e: 90},  // –£–≥–æ–ª (0,5)
                {cx: 3.5, cy: 4.5, r: 0.5, s: 90, e: 0},    // –£–≥–æ–ª (4,5)
                {cx: 3.5, cy: 4.5, r: 0.5, s: 0, e: -90},   // –í–Ω—É—Ç—Ä. —É–≥–æ–ª (4,4)
                {cx: 1.5, cy: 3.5, r: 0.5, s: 90, e: 180},  // –í–Ω—É—Ç—Ä. —É–≥–æ–ª (1,4)
                {cx: 1.5, cy: 1.5, r: 0.5, s: 180, e: 270}, // –í–Ω—É—Ç—Ä. —É–≥–æ–ª (1,1)
                {cx: 3.5, cy: 1.5, r: 0.5, s: 270, e: 360}  // –í–Ω—É—Ç—Ä. —É–≥–æ–ª (4,1)
            ];

            const steps = 5; // 5 –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö —Ç–æ—á–µ–∫ –Ω–∞ —É–≥–æ–ª (–≤—Å–µ–≥–æ 6 –Ω–∞ –¥—É–≥—É)
            
            // –í–µ—Ä—à–∏–Ω—ã –¥–ª—è –ø–µ—Ä–µ–¥–Ω–µ–π (z=1) –∏ –∑–∞–¥–Ω–µ–π (z=0) –≥—Ä–∞–Ω–µ–π
            for (let z of [1, 0]) {
                for (let c of corners) {
                    for (let i = 0; i <= steps; i++) {
                        const angle = (c.s + (c.e - c.s) * (i / steps)) * Math.PI / 180;
                        initialVertices.push([
                            c.cx + c.r * Math.cos(angle),
                            c.cy + c.r * Math.sin(angle),
                            z
                        ]);
                    }
                }
            }

            const ptsPerFace = corners.length * (steps + 1);
            for (let i = 0; i < ptsPerFace; i++) {
                const next = (i + 1) % ptsPerFace;
                edges.push([i, next]); // –ü–µ—Ä–µ–¥–Ω—è—è –≥—Ä–∞–Ω—å
                edges.push([i + ptsPerFace, next + ptsPerFace]); // –ó–∞–¥–Ω—è—è –≥—Ä–∞–Ω—å
                edges.push([i, i + ptsPerFace]); // –ü–µ—Ä–µ–º—ã—á–∫–∏
            }
        }

        generateGeometry();

        let transformationMatrix = math.identity(4);

        function getTransformedVertices() {
            let verticesHomogeneous = initialVertices.map(v => [...v, 1]);
            let matrixT = math.transpose(transformationMatrix);
            let transformed = math.multiply(verticesHomogeneous, matrixT);
            return transformed.toArray().map(v => [v[0], v[1], v[2]]);
        }

        function applyMatrix(newMatrix) {
            transformationMatrix = math.multiply(newMatrix, transformationMatrix);
            updateView();
        }

        function applyRotation(axis) {
            let angle = parseFloat(document.getElementById('rot' + axis.toUpperCase()).value) * (Math.PI / 180);
            let M = math.identity(4).toArray();
            let c = Math.cos(angle), s = Math.sin(angle);
            if (axis === 'x') { M[1][1] = c; M[1][2] = -s; M[2][1] = s; M[2][2] = c; }
            else if (axis === 'y') { M[0][0] = c; M[0][2] = s; M[2][0] = -s; M[2][2] = c; }
            else { M[0][0] = c; M[0][1] = -s; M[1][0] = s; M[1][1] = c; }
            applyMatrix(M);
        }

        function applyScale() {
            let s = parseFloat(document.getElementById('scaleVal').value);
            let M = math.identity(4).toArray();
            M[0][0] = s; M[1][1] = s; M[2][2] = s;
            applyMatrix(M);
        }

        function applyTranslation() {
            let dx = parseFloat(document.getElementById('transX').value);
            let dy = parseFloat(document.getElementById('transY').value);
            let dz = parseFloat(document.getElementById('transZ').value);
            let M = math.identity(4).toArray();
            M[0][3] = dx; M[1][3] = dy; M[2][3] = dz;
            applyMatrix(M);
        }

        function resetView() {
            transformationMatrix = math.identity(4);
            document.querySelectorAll('input').forEach(i => {
                if(i.id === 'scaleVal') i.value = 1;
                else if(i.id.startsWith('rot') || i.id.startsWith('trans')) i.value = 0;
            });
            updateView();
        }

        function updateView() {
            let currentVertices = getTransformedVertices();
            let x = [], y = [], z = [];
            edges.forEach(e => {
                let p1 = currentVertices[e[0]], p2 = currentVertices[e[1]];
                x.push(p1[0], p2[0], null); y.push(p1[1], p2[1], null); z.push(p1[2], p2[2], null);
            });

            let mat = transformationMatrix.toArray();
            document.getElementById('matrixOutput').value = mat.map(row =>
                row.map(v => v.toFixed(2).padStart(6, ' ')).join(' ')
            ).join('\n');

            let layout = {
                paper_bgcolor: '#0f172a',
                plot_bgcolor: '#0f172a',
                margin: { l: 0, r: 0, t: 0, b: 0 },
                showlegend: false,
                scene: {
                    aspectmode: 'data',
                    xaxis: { gridcolor: '#334155', color: '#94a3b8', zerolinecolor: '#38bdf8' },
                    yaxis: { gridcolor: '#334155', color: '#94a3b8', zerolinecolor: '#38bdf8' },
                    zaxis: { gridcolor: '#334155', color: '#94a3b8', zerolinecolor: '#38bdf8' },
                    camera: { eye: { x: 1.5, y: 1.5, z: 1.5 } }
                }
            };

            Plotly.react('plot3d', [
                { type: 'scatter3d', mode: 'lines', x: x, y: y, z: z, line: { width: 4, color: '#38bdf8' } },
                { type: 'scatter3d', mode: 'markers', x: currentVertices.map(v => v[0]), y: currentVertices.map(v => v[1]), z: currentVertices.map(v => v[2]), marker: { size: 2, color: '#f472b6' } }
            ], layout);
        }

        function showProjections() {
            document.getElementById('projModal').style.display = 'flex';
            let verts = getTransformedVertices();
            const draw2d = (id, i1, i2, title, ax1, ax2) => {
                let px = [], py = [];
                edges.forEach(e => {
                    px.push(verts[e[0]][i1], verts[e[1]][i1], null);
                    py.push(verts[e[0]][i2], verts[e[1]][i2], null);
                });
                Plotly.newPlot(id, [{
                    type: 'scatter', mode: 'lines', x: px, y: py,
                    line: { color: '#38bdf8' }
                }], {
                    title: { text: title, font: { color: '#f1f5f9' } },
                    paper_bgcolor: '#0f172a', plot_bgcolor: '#0f172a',
                    margin: { l: 40, r: 20, t: 40, b: 40 },
                    xaxis: { color: '#94a3b8', gridcolor: '#1e293b' },
                    yaxis: { color: '#94a3b8', gridcolor: '#1e293b', scaleanchor: "x" }
                });
            };
            draw2d('projXY', 0, 1, '–í–∏–¥ —Å–≤–µ—Ä—Ö—É (XY)', 'X', 'Y');
            draw2d('projXZ', 0, 2, '–í–∏–¥ —Å–ø–µ—Ä–µ–¥–∏ (XZ)', 'X', 'Z');
            draw2d('projYZ', 1, 2, '–í–∏–¥ —Å–±–æ–∫—É (YZ)', 'Y', 'Z');
        }

        function closeProjections() { document.getElementById('projModal').style.display = 'none'; }

        updateView();
        window.onresize = () => Plotly.Plots.resize('plot3d');
    </script>
</body>
</html>
